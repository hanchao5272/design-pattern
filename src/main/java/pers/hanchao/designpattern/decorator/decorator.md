# 装饰者模式
## 场景：生日蛋糕装饰
- 生日蛋糕在制作过程中，可以添加一系列装饰，例如：奶油、水果、饼干等等。
- 每种装饰品都有独特的计量单位，例如：10个饼干、6片水果等等，每种装饰品都有其价格。
- 每种蛋糕的装饰流程更不相同，例如：水果蛋糕装饰流程：蛋糕胚+奶油+水果，奶油蛋糕装饰流程：蛋糕+奶油。
- 在装修完成之后，列出装饰过程及价格。
- 随着市场变化，可能会增减新的装饰品，例如：因价格上涨，暂无饼干可用；新引进了装饰品巧克力。

## 实现方式1：每种蛋糕一个子类

**缺点：**

- `实现复杂`：几百种蛋糕需要几百个类。
- `复用性低`：每种蛋糕类的代码基本不会复用，存在大量重复代码。违背设计原则：`面向接口编程`。
- `扩展性差`：如果需求发送变化，例如蛋糕胚价格发送变化，则可能修改几百个类。违背设计原则`对修改关闭,对扩展放开`。

## 实现方式2：所有蛋糕共用一个大类

**缺点：**

- `扩展性差`：如果需求发送变化，例如新增一种装饰品巧克力，则必然需要修改SuperCake，违背设计原则`对修改关闭,对扩展放开`。

## 实现方式3：装饰者模式

**优点：**

- `复用性高`：只要使用某种装饰品，则必然复用其代码。
- `扩展性高`：如果需求发送变化，例如新增一种装饰品巧克力，则只需要新增一种装饰品`ChocolateDecorator`即可。

## 装饰者模式的实际应用

- 场景：
    - `HttpServletRequest`的body是流格式，只可读取一次。
    - 通过自定义包装类`RequestBodyWrapper.java`继承HttpServletRequestWrapper，重写getInputStream和getReader实现了对HttpServletRequest请求的包装，将body数据提取出来放入byte数组中，从而实现request中body数据的多次使用。
- URL: [Spring MVC代码实例系列-11：Spring MVC实现简单的权限控制拦截器和请求信息统计拦截器](https://blog.csdn.net/hanchao5272/article/details/79163897)